-Whitespaces instead of tabs, 2 whitespaces
-tests by had (no classes)
-doxygen comments



-------------------------------


class ICPState {
    // current search box 
   (Hash?)Map<Var, Interval> searchBox;
    // applied contraction
    ContractionCandidate contractionCandidate;
    // dimension in which split occured (if any occurred)
    Variable var;
    // reasons for a conflict
    vector<Formula> conflictReason;
}

// if not existing
class ContractionCandidate {
    Variable var;
    Formula formula;
}

class ICPTree {
    // current ICP state
    ICPState* icpState;
    // child states
    vector<ICPTree*> children;
    // parent state
    optional<ICPState*> parent;
}

//---------------------------------------------

// members:
ICPTree icpTree;

// uses the ICP algorithm on this icp state
Answer handleICPState(ICPState* state) {
    if (!checkForNonEmptyBoxes()) {
         return UNSAT;
    }
    if (checkForTerminationCondition()) { // target diameter and # of iterations
        // call CAD with this ICPState’s box
        return CAD(???);
    }
    else {
        CC = chooseContractionCandidate(); // best gain heuristic, returns optional
        if (CC.empty()) {
             // split box, create two new ICPStates, add them as children to the tree
             // call handleICPState on these two children
             ICPState leftState(boxLeft, CC, null, null);
            ICPState rightState(boxRight, CC, null, null);
            icpTree.addChild(leftState); //also add father node etc.
            icpTree.addChild(rightState);
            
            Answer leftAnswer = handleState(leftState); // evtl multi threaded
            Answer rightAnswer = handleState(rightState);
            // if answer unsat => propagate reasons upwards in the tree
        }
        else {
            Box b = applyContraction(icpState, CC);
            b = intersect(b, oldBox);
            ICPState newState(box, CC, null, null);
            icpState.addChild(newState);

            Answer answer = handleState(newState);
            // if answer unsat => propagate reasons upwards in the tree
        }
    }
}

Answer checkCore() {
    Sanitizing/ Init
    if no formulas -> return sat;
     
    Answer status = handleState(initState);
    
    return UNSAT;
}

void removeCore(...){
   find first occurence in tree
   delete children
}

add: trivial: add clauses to vector
init: depends: init the tree root

updateModel() { 
   // return set of UNSAT clauses
    return reasons from root node of icpTree
}

informCore(){
   ???    
}







////-----------------------------------------------------------------------------------
Input: smt input file als input format für compeierte binary
        -> .smt2
        -> smtlib.org  ->  rechts benchmarks -> availible here -> QF NRA.zip als test (nehme zu anfang die kleinste datei am besten
        -
CADOnlyAssignement.h -> kopieren und CADMoodule durch unser modul ersetzten include und 

--> smtrat -> ccmake.. --> DEVELOPER und LOGGIN anmachen, SMTRAT_Strategy auf unsere strategie stellen
                            --> statistics für statistiken

in CADModule.cpp
Loggin -> SMTRAT_LOG_ERROR
    -> chanel-> wo
    -> zweites die ausgabe

smtratSolver.cpp  -> oben wird gezeigt in LOGGIN wo welche ausgabe generiert

./smtrat --help 


Informationen kann man in Modules nachgucken

mModel -> muss mit einen assignement gefüllt werden wenn es SAT ist


Lifecycle:
    1.Für jeden constraint wird informCore aufgerufen. -> man kann dann gucken welche constraints aufgetaucht sind.
    2.init
    3.per addCore werden sachen zur menge der betrachten sachen zugegeben. mit remove löschen.  --> mit .formula kriegt man die formeln
        -> iterator: eine einzige formel
    4.Achtung -> das löschen wird nicht in der selben reihenfolge gemacht wie das adden
    5.addCore -> man kann false ausgeben, wenn es shcon nicht lösbar sind
    6.checkCore: checke ob betrachtete lösbar 

Bei UNSAT muss man ein infisible subset generieren -> mit: generateTrivialInfeasible...

mit runBackeds kann man ein zusätzliches backend aufrufen 

Wichtig -> updateModel in wiki angucken udn implementieren

FPPSettings -> kann man settings verwenden


-> CARL -> constraints/polynom 

-> Carl -> interval evaluation

-> in COMMON.h soll man am besten die sachen verwenden 
    



--------------------------

TODO:

überall pointer auf null setzten in constructoren

1. Linearisierung
2. Umformen+Einsetzten
3. CC auswählen mit meißten gain








